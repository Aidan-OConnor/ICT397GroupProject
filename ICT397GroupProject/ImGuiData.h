#pragma once
#include <sol/sol.hpp>
#include <imgui/imgui.h>

#include "Landscape.h"
#include "model.h"
#include "Camera.h"
#include "MD2Loader.h"

/*
 * @class ImGuiData
 * @brief Contains data and functions for loading and rendering objects
 *
 * ImGuiData stores all the data related to objects that have been loaded
 * in from ImGui or are to be rendered using locations generated by ImGui,
 * as well as the functions necessary to load the GUI and create new objects
 *
 * @author Aidan O'Connor
 * @version 02
 * @date 09/06/2023 Aidan O'Connor, finished
 *
 * @bug No bugs have currently been found
 */

struct objectData
{
    const char* filepath;
    const char* texturePath;
    const char* weaponPath;
    const char* weaponTexturePath;
    const char* objectType;
    float iterations, width, length, minHeight, maxHeight, filter;
    float tx, ty, tz;
    float sx, sy, sz;
    float rx, ry, rz;
    bool isPlayer;
    bool isDock;
    bool isHut;
    bool isCollectable;

    objectData() {};
};

class ImGuiData
{
private:
    /// Stores the iterations for a fault formation
    float iterations;
    /// Stores the width for a fault formation
    float width;
    /// Stores the length for a fault formation
    float length;
    /// Stores the minimum height for a fault formation
    float minHeight;
    /// Stores the maximum height for a fault formation
    float maxHeight; 
    /// Stores the filter for a fault formation
    float filter;
    /// Stores an index of the currently rendered map
    int currentMap;
    /// Stores the player status of a stored object
    bool isPlayer;
    /// Stores the status of whether an object is a dock or not
    bool isDock;
    /// Stores the status of whether an object is a hut or not
    bool isHut;
    /// Stores the status of whether an object is collectable or not
    bool isCollectable;
    /// Stores the data types file path as a const char *
    std::string filepath;
    /// Stores the data types texture path as a const char *
    std::string texturePath;
    /// Stores the objects type in a string
    std::string objectType;
    /// Stores the landscape type in a string
    std::string landscapeType;
    /// Stores a landscape for a terrain
    Landscape terrain;
    /// Stores a landscape for water
    Landscape water;
    /// Stores a temporary landscape for pushing data
    Landscape tempLandscape;
    /// Stores a model
    Model* model;
    /// Stores the object name
    const char* objectName;
    /// Stores the 3D translation of an object
    glm::vec3 translation;
    /// Stores the 3D scale of an object
    glm::vec3 scale;
    /// Stores the 3D rotation of an object
    glm::vec3 rotation;
    /// Stores all of the loaded objects
    std::vector<ImGuiData> imGuiObjects;
    /// Stores all of the data loaded in from Lua
    std::vector<objectData> luaMap;
    /// Stores a tempory string
    std::string tempName;
    /// Stores the names of all heightmaps
    std::vector<std::string> heightmaps;
    /// Stores the names of all maps
    std::vector<std::string> maps;
    /// Stores the names of all models
    std::vector<std::string> models;
    /// Stores the names of all md2 models
    std::vector<std::string> md2Models;
    /// Stores an md2 loaded model
    MD2Loader md2Model;
    /// Stores an md2 loaded model to be used as a weapon
    MD2Loader weapon;
    /// Stores an md2 models animation state
    animationState animState;
    /// Stores the file path to the weapon md2 file
    std::string weaponPath;
    /// Stores the file path to the weapons texture
    std::string weaponTexturePath;
    /// Stores the current from for delta time
    float currentFrame;
    /// Stores the delta time
    float deltaTime;
    /// Stores the last frame for delta time
    float lastFrame;

public:
    /// Temporary terrain for pushing data
    Terrain temp;
    /// Default height scale for a terrain
    int heightScale = 1;

    /*
     * @brief Default ImGuiData constructor
     *
     * The default constructor for an ImGuiObject that
     * initializes some necessary values to 0
     *
     * @return void
     */
    ImGuiData()
    {
        this->iterations = this->width = this->length = 
            this->minHeight = this->maxHeight = this->filter = 0;
        this->isPlayer = false;
        this->isDock = false;
        this->isHut = false;
        this->isCollectable = false;
        this->animState = md2Model.startAnimation(STAND);
        this->weaponPath.clear();
        this->weaponTexturePath.clear();
        this->currentMap = 0;

        sol::state lua;
        lua.open_libraries(sol::lib::base);
        lua.script_file("ModelFiles.lua");

        int numModels = lua["numModels"];

        for (int i = 0; i < numModels; i++)
        {
            std::string tempName = "Model" + std::to_string(i + 1);
            const char* mapName = tempName.c_str();
            std::string tempModel = lua["models"][mapName];
            this->models.push_back(tempModel);
        }

        lua.script_file("HeightmapFiles.lua");

        int numHeightmaps = lua["numHeightmaps"];

        for (int i = 0; i < numHeightmaps; i++)
        {
            std::string tempName = "Heightmap" + std::to_string(i + 1);
            const char* mapName = tempName.c_str();
            std::string tempHMap = lua["heightmaps"][mapName];
            this->heightmaps.push_back(tempHMap);
        }

        lua.script_file("Md2Models.lua");

        int numMd2Models = lua["numMd2Models"];

        for (int i = 0; i < numMd2Models; i++)
        {
            std::string tempName = "ModelF" + std::to_string(i + 1);
            const char* md2Name = tempName.c_str();
            std::string tempMd2 = lua["md2Models"][md2Name];
            this->md2Models.push_back(tempMd2);

            tempName = "ModelT" + std::to_string(i + 1);
            md2Name = tempName.c_str();
            std::string tempMd21 = lua["md2Models"][md2Name];
            this->md2Models.push_back(tempMd21);

            tempName = "WeaponF" + std::to_string(i + 1);
            md2Name = tempName.c_str();
            std::string tempMd22 = lua["md2Models"][md2Name];
            this->md2Models.push_back(tempMd22);

            tempName = "WeaponT" + std::to_string(i + 1);
            md2Name = tempName.c_str();
            std::string tempMd23 = lua["md2Models"][md2Name];
            this->md2Models.push_back(tempMd23);
        }
    }

    /*
     * @brief Gets the number of a certain model type
     *
     * This function returns the number of a certain
     * model type is being stored for the current map
     *
     * @param modelType
     * @return numOfType
     */
    int getNumType(std::string modelType)
    {
        int numOfType = 0;

        for (int i = 0; i < imGuiObjects.size(); i++)
        {
            if (imGuiObjects[i].objectType == modelType)
            {
                numOfType++;
            }
        }

        return numOfType;
    }

    /*
     * @brief Renders the UI
     *
     * This functions renders all of the UI for the scene
     * to allows users to customize their map.
     *
     * @return void
     */
    void RenderUI(Camera& camera)
    {

        ImGui::Begin("Control Centre");

        if (ImGui::TreeNode("Create Terrain"))
        {
            if (ImGui::TreeNode("Heightmap"))
            {
                for (int i = 0; i < heightmaps.size(); i++)
                {
                    std::string tempName;
                    for (int j = 0; j < heightmaps[i].size(); j++)
                    {
                        if (heightmaps[i][j] == '.')
                            j = heightmaps[i].size();
                        if (heightmaps[i][j] == '/')
                            tempName.clear();
                        else
                            tempName += heightmaps[i][j];
                    }

                    if (i % 3 != 0)
                    {
                        ImGui::SameLine();
                    }

                    if (ImGui::Button(tempName.c_str(), ImVec2(100, 25)))
                    {
                        ImGuiData ImTemp;

                        ImTemp.objectType = "Terrain";
                        ImTemp.landscapeType = "Heightmap";
                        ImTemp.terrain.loadFromHeightmap(heightmaps[i].c_str(), 1, "Images/sand2.jpg", GL_TEXTURE_2D);
                        ImTemp.terrain.addTextures("Images/Ground2.jpg", GL_TEXTURE_2D, "Images/Grass.jpg", GL_TEXTURE_2D);
                        ImTemp.translation = { 0.0f, 0.0f, 0.0f };
                        ImTemp.scale = { 1.0f, 1.0f, 1.0f };
                        ImTemp.filepath = heightmaps[i];
                        ImTemp.texturePath = "Images/sand2.jpg";

                        imGuiObjects.push_back(ImTemp);
                    }
                }
                ImGui::TreePop();
            }
            if (ImGui::TreeNode("Fault Formation"))
            {
                ImGui::InputFloat("Iterations", &iterations);
                ImGui::InputFloat("Width", &width);
                ImGui::InputFloat("Length", &length);
                ImGui::InputFloat("Minimim height", &minHeight);
                ImGui::InputFloat("Maximum height ", &maxHeight);
                ImGui::InputFloat("Filter", &filter);

                if (ImGui::Button("Generate", ImVec2(100, 25)))
                {
                    ImGuiData ImTemp;
                    ImTemp.objectType = "Terrain";
                    ImTemp.landscapeType = "Formation";
                    ImTemp.terrain.loadFromFaultFormation(iterations, width, length, 1, 1, minHeight, maxHeight, filter, "Images/sand2.jpg", GL_TEXTURE_2D);
                    ImTemp.terrain.addTextures("Images/Ground2.jpg", GL_TEXTURE_2D, "Images/Grass.jpg", GL_TEXTURE_2D);
                    ImTemp.translation = { 0.0f, 0.0f, 0.0f };
                    ImTemp.scale = { 1.0f, 1.0f, 1.0f };
                    ImTemp.texturePath = "Images/sand2.jpg";

                    imGuiObjects.push_back(ImTemp);

                    iterations = width = length = minHeight = maxHeight = filter = 0;
                }
                ImGui::TreePop();
            }
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Create Water"))
        {
            if (ImGui::TreeNode("Fault Formation"))
            {
                ImGui::InputFloat("Iterations", &iterations);
                ImGui::InputFloat("Width", &width);
                ImGui::InputFloat("Length", &length);
                ImGui::InputFloat("Minimim height", &minHeight);
                ImGui::InputFloat("Maximum height ", &maxHeight);
                ImGui::InputFloat("Filter", &filter);

                if (ImGui::Button("Generate", ImVec2(100, 25)))
                {
                    ImGuiData ImTemp;
                    ImTemp.objectType = "Water";
                    ImTemp.landscapeType = "Formation";
                    ImTemp.terrain.loadFromFaultFormation(iterations, width, length, 1, 1, minHeight, maxHeight, filter, "Images/Water1.jpg", GL_TEXTURE_2D);
                    ImTemp.translation = { 0.0f, 0.0f, 0.0f };
                    ImTemp.scale = { 1.0f, 1.0f, 1.0f };
                    ImTemp.texturePath = "Images/Water1.jpg";

                    imGuiObjects.push_back(ImTemp);

                    iterations = width = length = minHeight = maxHeight = filter = 0;
                }
                ImGui::TreePop();
            }
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Load Model"))
        {
            for (int i = 0; i < models.size(); i++)
            {
                std::string tempName;
                for (int j = 0; j < models[i].size(); j++)
                {
                    if (models[i][j] == '.')
                        j = models[i].size();
                    if (models[i][j] == '/')
                        tempName.clear();
                    else
                        tempName += models[i][j];
                }

                if (i % 3 != 0)
                {
                    ImGui::SameLine();
                }

                if (ImGui::Button(tempName.c_str(), ImVec2(100, 25)))
                {
                    ImGuiData ImTemp;
                    ImTemp.objectType = "Model";
                    ImTemp.model = new Model(models[i]);
                    ImTemp.translation = { 0.0f, 0.0f, 0.0f };
                    ImTemp.scale = { 1.0f, 1.0f, 1.0f };
                    ImTemp.filepath = models[i];

                    imGuiObjects.push_back(ImTemp);
                }
            }
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Load Special Component"))
        {
            if (ImGui::TreeNode("Load Player"))
            {
                if (ImGui::TreeNode("Boat"))
                {
                    if (ImGui::Button("Load", ImVec2(100, 25)))
                    {
                        ImGuiData ImTemp;
                        ImTemp.objectType = "Model";
                        ImTemp.model = new Model("Models/NewBoat/boat.obj");
                        ImTemp.translation = { 0.0f, 0.0f, 0.0f };
                        ImTemp.scale = { 1.0f, 1.0f, 1.0f };
                        ImTemp.filepath = "Models/NewBoat/boat.obj";
                        ImTemp.isPlayer = true;

                        imGuiObjects.push_back(ImTemp);
                    }
                    ImGui::TreePop();
                }
                ImGui::TreePop();
            }
            if (ImGui::TreeNode("Load Dock"))
            {
                if (ImGui::TreeNode("Dock"))
                {
                    if (ImGui::Button("Load", ImVec2(100, 25)))
                    {
                        ImGuiData ImTemp;
                        ImTemp.objectType = "Model";
                        ImTemp.model = new Model("Models/Dock/Dock.obj");
                        ImTemp.translation = { 0.0f, 0.0f, 0.0f };
                        ImTemp.scale = { 1.0f, 1.0f, 1.0f };
                        ImTemp.filepath = "Models/Dock/Dock.obj";
                        ImTemp.isDock = true;

                        imGuiObjects.push_back(ImTemp);
                    }
                    ImGui::TreePop();
                }
                ImGui::TreePop();
            }
            if (ImGui::TreeNode("Load Hut"))
            {
                if (ImGui::TreeNode("Hut"))
                {
                    if (ImGui::Button("Load", ImVec2(100, 25)))
                    {
                        ImGuiData ImTemp;
                        ImTemp.objectType = "Model";
                        ImTemp.model = new Model("Models/Hut/hut.obj");
                        ImTemp.translation = { 0.0f, 0.0f, 0.0f };
                        ImTemp.scale = { 1.0f, 1.0f, 1.0f };
                        ImTemp.filepath = "Models/Hut/hut.obj";
                        ImTemp.isHut = true;

                        imGuiObjects.push_back(ImTemp);
                    }
                    ImGui::TreePop();
                }
                ImGui::TreePop();
            }
            if (ImGui::TreeNode("Load Collectable"))
            {
                if (ImGui::TreeNode("Plank"))
                {
                    if (ImGui::Button("Load", ImVec2(100, 25)))
                    {
                        ImGuiData ImTemp;
                        ImTemp.objectType = "Model";
                        ImTemp.model = new Model("Models/Plank/plank.obj");
                        ImTemp.translation = { 0.0f, 0.0f, 0.0f };
                        ImTemp.scale = { 1.0f, 1.0f, 1.0f };
                        ImTemp.filepath = "Models/Plank/plank.obj";
                        ImTemp.isCollectable = true;

                        imGuiObjects.push_back(ImTemp);
                    }
                    ImGui::TreePop();
                }
                ImGui::TreePop();
            }
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Load NPC"))
        {
            for (int i = 0; i < md2Models.size(); i+=4)
            {
                std::string tempName;
                for (int j = 0; j < md2Models[i].size(); j++)
                {
                    if (md2Models[i][j] == '.')
                        j = md2Models[i].size();
                    if (md2Models[i][j] == '/')
                        tempName.clear();
                    else
                        tempName += md2Models[i][j];
                }

                if (i % 3 != 0)
                {
                    ImGui::SameLine();
                }

                if (ImGui::Button(tempName.c_str(), ImVec2(100, 25)))
                {
                    ImGuiData ImTemp;
                    ImTemp.objectType = "Animation";
                    ImTemp.animState = md2Model.startAnimation(STAND);
                    ImTemp.md2Model.loadModel(md2Models[i].c_str(), md2Models[i+1].c_str());
                    if (md2Models[i + 2] != "")
                        ImTemp.weapon.loadModel(md2Models[i + 2].c_str(), md2Models[i + 3].c_str());
                    ImTemp.translation = { 0.0f, 0.0f, 0.0f };
                    ImTemp.scale = { 1.0f, 1.0f, 1.0f };
                    ImTemp.filepath = md2Models[i];
                    ImTemp.weaponPath = md2Models[i+2];
                    ImTemp.texturePath = md2Models[i+1];
                    ImTemp.weaponTexturePath = md2Models[i+3];

                    imGuiObjects.push_back(ImTemp);
                }
            }
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Object Data"))
        {
            if (imGuiObjects.size() != 0)
            {
                for (int i = 0; i < imGuiObjects.size(); i++)
                {
                    std::string tempName;
                    if (imGuiObjects[i].objectType == "Terrain")
                    {
                        tempName = "Terrain" + std::to_string(i);
                    }
                    else if (imGuiObjects[i].objectType == "Water")
                    {
                        tempName = "Water" + std::to_string(i);
                    }
                    else if (imGuiObjects[i].objectType == "Model")
                    {
                        tempName = "Model" + std::to_string(i);
                    }
                    else if (imGuiObjects[i].objectType == "Animation")
                    {
                        tempName = "Animation" + std::to_string(i);
                    }

                    imGuiObjects[i].objectName = tempName.c_str();

                    if (ImGui::TreeNode(imGuiObjects[i].objectName))
                    {
                        if (ImGui::Button("Focus", ImVec2(100, 25)))
                            camera.updatePosition(imGuiObjects[i].translation);

                        ImGui::SameLine();

                        if (ImGui::Button("Delete", ImVec2(100, 25)))
                            imGuiObjects.erase(imGuiObjects.begin() + i);

                        ImGui::DragFloat("PositionX", &imGuiObjects[i].translation[0], 0.5, -10000, 10000);
                        ImGui::DragFloat("PositionY", &imGuiObjects[i].translation[1], 0.5, -10000, 10000);
                        ImGui::DragFloat("PositionZ", &imGuiObjects[i].translation[2], 0.5, -10000, 10000);
                        ImGui::InputFloat3("Position", &imGuiObjects[i].translation[0]);
                        ImGui::DragFloat("ScaleX", &imGuiObjects[i].scale[0], 0.005, -50, 50);
                        ImGui::DragFloat("ScaleY", &imGuiObjects[i].scale[1], 0.005, -50, 50);
                        ImGui::DragFloat("ScaleZ", &imGuiObjects[i].scale[2], 0.005, -50, 50);
                        ImGui::InputFloat3("Scale", &imGuiObjects[i].scale[0]);
                        ImGui::DragFloat("RotationX", &imGuiObjects[i].rotation[0], 0.01, -360, 360);
                        ImGui::DragFloat("RotationY", &imGuiObjects[i].rotation[1], 0.01, -360, 360);
                        ImGui::DragFloat("RotationZ", &imGuiObjects[i].rotation[2], 0.01, -360, 360);
                        ImGui::InputFloat3("Rotation", &imGuiObjects[i].rotation[0]);

                        ImGui::TreePop();
                    }
                }
            }
            ImGui::TreePop();
        }

        if (ImGui::TreeNode("Save/Load Map"))
        {
            if (ImGui::Button("Save", ImVec2(100, 25)))
            {
                int numOfTerrain = getNumType("Terrain");
                int numOfWater = getNumType("Water");
                int numOfModel = getNumType("Model");
                int numOfAnimations = getNumType("Animation");
                int tCount = 0;
                int wCount = 0;
                int mCount = 0;
                int aCount = 0;

                std::ofstream luaMap;
                luaMap.open(maps[currentMap]);
                luaMap << "numTerrains = " << numOfTerrain << "\n";
                luaMap << "numWater = " << numOfWater << "\n";
                luaMap << "numModels = " << numOfModel << "\n";
                luaMap << "numAnimations = " << numOfAnimations << "\n";

                for (int i = 0; i < imGuiObjects.size(); i++)
                {
                    if (imGuiObjects[i].objectType == "Terrain")
                    {
                        luaMap << "terrain" << tCount << " = objectData.new()\n";
                        tCount++;
                    }
                    else if (imGuiObjects[i].objectType == "Water")
                    {
                        luaMap << "water" << wCount << " = objectData.new()\n";
                        wCount++;
                    }
                    else if (imGuiObjects[i].objectType == "Model")
                    {
                        luaMap << "model" << mCount << " = objectData.new()\n";
                        mCount++;
                    }
                    else if (imGuiObjects[i].objectType == "Animation")
                    {
                        luaMap << "animation" << aCount << " = objectData.new()\n";
                        aCount++;
                    }
                }

                tCount = wCount = mCount = aCount = 0;

                for (int i = 0; i < imGuiObjects.size(); i++)
                {
                    if (imGuiObjects[i].objectType == "Terrain")
                    {
                        luaMap << "\n";
                        luaMap << "terrain" << tCount << ".objectType = \"" << imGuiObjects[i].objectType << "\"\n";
                        luaMap << "terrain" << tCount << ".filepath = \"" << imGuiObjects[i].filepath << "\"\n";
                        luaMap << "terrain" << tCount << ".texturePath = \"" << imGuiObjects[i].texturePath << "\"\n";
                        luaMap << "terrain" << tCount << ".tx = " << imGuiObjects[i].translation.x << "\n";
                        luaMap << "terrain" << tCount << ".ty = " << imGuiObjects[i].translation.y << "\n";
                        luaMap << "terrain" << tCount << ".tz = " << imGuiObjects[i].translation.z << "\n";
                        luaMap << "terrain" << tCount << ".sx = " << imGuiObjects[i].scale.x << "\n";
                        luaMap << "terrain" << tCount << ".sy = " << imGuiObjects[i].scale.y << "\n";
                        luaMap << "terrain" << tCount << ".sz = " << imGuiObjects[i].scale.z << "\n";
                        luaMap << "terrain" << tCount << ".rx = " << imGuiObjects[i].rotation.x << "\n";
                        luaMap << "terrain" << tCount << ".ry = " << imGuiObjects[i].rotation.y << "\n";
                        luaMap << "terrain" << tCount << ".rz = " << imGuiObjects[i].rotation.z << "\n";
                        tCount++;
                    }
                    else if (imGuiObjects[i].objectType == "Water")
                    {
                        luaMap << "\n";
                        luaMap << "water" << wCount << ".objectType = \"" << imGuiObjects[i].objectType << "\"\n";
                        luaMap << "water" << wCount << ".iterations = " << imGuiObjects[i].iterations << "\n";
                        luaMap << "water" << wCount << ".width = " << imGuiObjects[i].width << "\n";
                        luaMap << "water" << wCount << ".length = " << imGuiObjects[i].length << "\n";
                        luaMap << "water" << wCount << ".minHeight = " << imGuiObjects[i].minHeight << "\n";
                        luaMap << "water" << wCount << ".maxHeight = " << imGuiObjects[i].maxHeight << "\n";
                        luaMap << "water" << wCount << ".filter = " << imGuiObjects[i].filter << "\n";
                        luaMap << "water" << wCount << ".texturePath = \"" << imGuiObjects[i].texturePath << "\"\n";
                        luaMap << "water" << wCount << ".tx = " << imGuiObjects[i].translation.x << "\n";
                        luaMap << "water" << wCount << ".ty = " << imGuiObjects[i].translation.y << "\n";
                        luaMap << "water" << wCount << ".tz = " << imGuiObjects[i].translation.z << "\n";
                        luaMap << "water" << wCount << ".sx = " << imGuiObjects[i].scale.x << "\n";
                        luaMap << "water" << wCount << ".sy = " << imGuiObjects[i].scale.y << "\n";
                        luaMap << "water" << wCount << ".sz = " << imGuiObjects[i].scale.z << "\n";
                        luaMap << "water" << wCount << ".rx = " << imGuiObjects[i].rotation.x << "\n";
                        luaMap << "water" << wCount << ".ry = " << imGuiObjects[i].rotation.y << "\n";
                        luaMap << "water" << wCount << ".rz = " << imGuiObjects[i].rotation.z << "\n";
                        wCount++;
                    }
                    else if (imGuiObjects[i].objectType == "Model")
                    {
                        luaMap << "\n";

                        if(imGuiObjects[i].isPlayer)
                            luaMap << "model" << mCount << ".isPlayer = true" << "\n";
                        else
                            luaMap << "model" << mCount << ".isPlayer = false" << "\n";

                        if (imGuiObjects[i].isDock)
                            luaMap << "model" << mCount << ".isDock = true" << "\n";
                        else
                            luaMap << "model" << mCount << ".isDock = false" << "\n";

                        if (imGuiObjects[i].isHut)
                            luaMap << "model" << mCount << ".isHut = true" << "\n";
                        else
                            luaMap << "model" << mCount << ".isHut = false" << "\n";

                        if (imGuiObjects[i].isCollectable)
                            luaMap << "model" << mCount << ".isCollectable = true" << "\n";
                        else
                            luaMap << "model" << mCount << ".isCollectable = false" << "\n";

                        luaMap << "model" << mCount << ".objectType = \"" << imGuiObjects[i].objectType << "\"\n";
                        luaMap << "model" << mCount << ".filepath = \"" << imGuiObjects[i].filepath << "\"\n";
                        luaMap << "model" << mCount << ".tx = " << imGuiObjects[i].translation.x << "\n";
                        luaMap << "model" << mCount << ".ty = " << imGuiObjects[i].translation.y << "\n";
                        luaMap << "model" << mCount << ".tz = " << imGuiObjects[i].translation.z << "\n";
                        luaMap << "model" << mCount << ".sx = " << imGuiObjects[i].scale.x << "\n";
                        luaMap << "model" << mCount << ".sy = " << imGuiObjects[i].scale.y << "\n";
                        luaMap << "model" << mCount << ".sz = " << imGuiObjects[i].scale.z << "\n";
                        luaMap << "model" << mCount << ".rx = " << imGuiObjects[i].rotation.x << "\n";
                        luaMap << "model" << mCount << ".ry = " << imGuiObjects[i].rotation.y << "\n";
                        luaMap << "model" << mCount << ".rz = " << imGuiObjects[i].rotation.z << "\n";
                        mCount++;
                    }
                    else if (imGuiObjects[i].objectType == "Animation")
                    {
                        luaMap << "\n";
                        luaMap << "animation" << aCount << ".objectType = \"" << imGuiObjects[i].objectType << "\"\n";
                        luaMap << "animation" << aCount << ".filepath = \"" << imGuiObjects[i].filepath << "\"\n";
                        luaMap << "animation" << aCount << ".texturePath = \"" << imGuiObjects[i].texturePath << "\"\n";
                        luaMap << "animation" << aCount << ".weaponPath = \"" << imGuiObjects[i].weaponPath << "\"\n";
                        luaMap << "animation" << aCount << ".weaponTexturePath = \"" << imGuiObjects[i].weaponTexturePath << "\"\n";
                        luaMap << "animation" << aCount << ".tx = " << imGuiObjects[i].translation.x << "\n";
                        luaMap << "animation" << aCount << ".ty = " << imGuiObjects[i].translation.y << "\n";
                        luaMap << "animation" << aCount << ".tz = " << imGuiObjects[i].translation.z << "\n";
                        luaMap << "animation" << aCount << ".sx = " << imGuiObjects[i].scale.x << "\n";
                        luaMap << "animation" << aCount << ".sy = " << imGuiObjects[i].scale.y << "\n";
                        luaMap << "animation" << aCount << ".sz = " << imGuiObjects[i].scale.z << "\n";
                        luaMap << "animation" << aCount << ".rx = " << imGuiObjects[i].rotation.x << "\n";
                        luaMap << "animation" << aCount << ".ry = " << imGuiObjects[i].rotation.y << "\n";
                        luaMap << "animation" << aCount << ".rz = " << imGuiObjects[i].rotation.z << "\n";
                        aCount++;
                    }
                }

                luaMap.close();
            }
            ImGui::SameLine();
            if (ImGui::Button("Load", ImVec2(100, 25)))
            {
                imGuiObjects.clear();
                loadData(imGuiObjects, maps, currentMap);
            }
            ImGui::SameLine();
            if (ImGui::Button("New", ImVec2(100, 25)))
            {
                imGuiObjects.clear();
            }
            if (ImGui::TreeNode("Load Map"))
            {
                for (int i = 0; i < maps.size(); i++)
                {
                    std::string tempName;
                    for (int j = 0; j < maps[i].size(); j++)
                    {
                        if (maps[i][j] == '.')
                            j = maps[i].size();
                        else
                            tempName += maps[i][j];
                    }

                    if (i % 3 != 0)
                    {
                        ImGui::SameLine();
                    }

                    if (ImGui::Button(tempName.c_str(), ImVec2(100, 25)))
                    {
                        imGuiObjects.clear();
                        currentMap = i;
                        loadData(imGuiObjects, maps, currentMap);
                    }
                }
            }
            ImGui::TreePop();
        }

        ImGui::End();
    }

    /*
     * @brief Renders the objects stored
     *
     * This function renders all of the objects stored
     * in the ImGuiData according to the object type
     *
     * @param shader, waterShader, lightingShader, camera
     * @return void
     */
    void RenderObjects(Shader shader, Shader waterShader, Shader lightingShader, Shader modelShader, Camera camera)
    {
        if (imGuiObjects.size() != 0)
        {
            for (int i = 0; i < imGuiObjects.size(); i++)
            {
                if (imGuiObjects[i].objectType == "Terrain")
                {
                    shader.use();
                    glm::mat4 model = glm::mat4(1.0f);
                    shader.setMat4("model", model);
                    model = glm::rotate(model, imGuiObjects[i].rotation[0], glm::vec3(1, 0, 0));
                    model = glm::rotate(model, imGuiObjects[i].rotation[1], glm::vec3(0, 1, 0));
                    model = glm::rotate(model, imGuiObjects[i].rotation[2], glm::vec3(0, 0, 1));
                    model = glm::translate(model, { imGuiObjects[i].translation[0], imGuiObjects[i].translation[1], imGuiObjects[i].translation[2]});
                    model = glm::scale(model, { imGuiObjects[i].scale[0], imGuiObjects[i].scale[1], imGuiObjects[i].scale[2] });
                    shader.setMat4("model", model);
                    imGuiObjects[i].terrain.renderLandscape(camera.getRenderType());
                    temp = imGuiObjects[i].terrain.getTerrain();
                    heightScale = imGuiObjects[i].scale[1];
                }
                else if (imGuiObjects[i].objectType == "Water")
                {
                    waterShader.use();
                    glm::mat4 model = glm::mat4(1.0f);
                    waterShader.setMat4("model", model);
                    model = glm::translate(model, { imGuiObjects[i].translation[0], imGuiObjects[i].translation[1], imGuiObjects[i].translation[2] });
                    model = glm::scale(model, { imGuiObjects[i].scale[0], imGuiObjects[i].scale[1], imGuiObjects[i].scale[2] });
                    model = glm::rotate(model, imGuiObjects[i].rotation[0], glm::vec3(1, 0, 0));
                    model = glm::rotate(model, imGuiObjects[i].rotation[1], glm::vec3(0, 1, 0));
                    model = glm::rotate(model, imGuiObjects[i].rotation[2], glm::vec3(0, 0, 1));
                    waterShader.setMat4("model", model);
                    imGuiObjects[i].terrain.renderWater(camera.getRenderType());
                }
                else if (imGuiObjects[i].objectType == "Model")
                {
                    lightingShader.use();
                    glm::mat4 model = glm::mat4(1.0f);
                    model = glm::translate(model, { imGuiObjects[i].translation[0], imGuiObjects[i].translation[1], imGuiObjects[i].translation[2] });
                    model = glm::scale(model, { imGuiObjects[i].scale[0], imGuiObjects[i].scale[1], imGuiObjects[i].scale[2] });
                    model = glm::rotate(model, imGuiObjects[i].rotation[0], glm::vec3(1, 0, 0));
                    model = glm::rotate(model, imGuiObjects[i].rotation[1], glm::vec3(0, 1, 0));
                    model = glm::rotate(model, imGuiObjects[i].rotation[2], glm::vec3(0, 0, 1));
                    lightingShader.setMat4("model", model);
                    imGuiObjects[i].model->Draw(lightingShader);
                }
                else if (imGuiObjects[i].objectType == "Animation")
                {
                    imGuiObjects[i].currentFrame = (float)glfwGetTime();
                    imGuiObjects[i].deltaTime = imGuiObjects[i].currentFrame - imGuiObjects[i].lastFrame;
                    imGuiObjects[i].lastFrame = imGuiObjects[i].currentFrame;
                    modelShader.use();
                    glm::mat4 model = glm::mat4(1.0f);
                    model = glm::translate(model, { imGuiObjects[i].translation[0], imGuiObjects[i].translation[1], imGuiObjects[i].translation[2] });
                    model = glm::scale(model, { imGuiObjects[i].scale[0], imGuiObjects[i].scale[1], imGuiObjects[i].scale[2] });
                    model = glm::rotate(model, imGuiObjects[i].rotation[0]-1.5f, glm::vec3(1, 0, 0));
                    model = glm::rotate(model, imGuiObjects[i].rotation[1], glm::vec3(0, 1, 0));
                    model = glm::rotate(model, imGuiObjects[i].rotation[2]-1.5f, glm::vec3(0, 0, 1));
                    modelShader.setMat4("model", model);
                    modelShader.setMat4("normal", model);
                    imGuiObjects[i].md2Model.renderModel(&imGuiObjects[i].animState, modelShader);
                    imGuiObjects[i].md2Model.updateAnimation(&imGuiObjects[i].animState, imGuiObjects[i].deltaTime);
                    if(imGuiObjects[i].weaponPath != "")
                    {
                        imGuiObjects[i].weapon.renderModel(&imGuiObjects[i].animState, modelShader);
                    }
                }
            }
        }
    }

    /*
     * @brief Loads in and stores data from Lua
     *
     * This function loads in map data from a Lua script
     * and stores it in a more useable data type
     *
     * @param convertedData
     * @return void
     */
    void loadData(std::vector<ImGuiData>& convertedData, std::vector<std::string>& mapList, int mapIndex)
    {
        this->maps = mapList;
        this->currentMap = mapIndex;
        luaMap.clear();
        sol::state lua;
        lua.open_libraries(sol::lib::base);

        lua.new_usertype<objectData>("objectData", sol::constructors<void()>(),
            "filepath", &objectData::filepath, "texturePath", &objectData::texturePath, "objectType", &objectData::objectType,
            "weaponPath", &objectData::weaponPath, "weaponTexturePath", &objectData::weaponTexturePath,
            "iterations", &objectData::iterations, "width", &objectData::width, "isPlayer", &objectData::isPlayer, 
            "isDock", &objectData::isDock, "isHut", &objectData::isHut, "isCollectable", &objectData::isCollectable, "length", &objectData::length,
            "minHeight", &objectData::minHeight, "maxHeight", &objectData::maxHeight, "filter", &objectData::filter,
            "tx", &objectData::tx, "ty", &objectData::ty, "tz", &objectData::tz,
            "sx", &objectData::sx, "sy", &objectData::sy, "sz", &objectData::sz,
            "rx", &objectData::rx, "ry", &objectData::ry, "rz", &objectData::rz
        );

        lua.script_file(maps[currentMap]);

        int numOfTerrain = lua["numTerrains"];
        int numOfWater = lua["numWater"];
        int numOfModel = lua["numModels"];
        int numOfAnimations = lua["numAnimations"];

        for (int i = 0; i < numOfTerrain; i++)
        {
            tempName = "terrain" + std::to_string(i);
            const char* terrainName = tempName.c_str();
            objectData& tempObject = lua[terrainName];
            luaMap.push_back(tempObject);
        }

        for (int i = 0; i < numOfWater; i++)
        {
            tempName = "water" + std::to_string(i);
            const char* waterName = tempName.c_str();
            objectData& tempObject1 = lua[waterName];
            luaMap.push_back(tempObject1);
        }

        for (int i = 0; i < numOfModel; i++)
        {
            tempName = "model" + std::to_string(i);
            const char* modelName = tempName.c_str();
            objectData& tempObject2 = lua[modelName];
            luaMap.push_back(tempObject2);
        }

        for (int i = 0; i < numOfAnimations; i++)
        {
            tempName = "animation" + std::to_string(i);
            const char* animationName = tempName.c_str();
            objectData& tempObject3 = lua[animationName];
            luaMap.push_back(tempObject3);
        }

        for (int i = 0; i < luaMap.size(); i++)
        {
            std::string objectType = luaMap[i].objectType;
            ImGuiData tempGuiData;

            if (objectType == "Terrain")
            {
                Landscape tempTerrain;
                tempTerrain.loadFromHeightmap(luaMap[i].filepath, 1, luaMap[i].texturePath, GL_TEXTURE_2D);
                tempTerrain.addTextures("Images/Ground2.jpg", GL_TEXTURE_2D, "Images/Grass.jpg", GL_TEXTURE_2D);
                tempGuiData.setTerrain(tempTerrain);
                tempGuiData.setObjectType(luaMap[i].objectType);
                tempGuiData.setFilePath(luaMap[i].filepath);
                tempGuiData.setTexturePath(luaMap[i].texturePath);
            }
            else if (objectType == "Water")
            {
                Landscape tempTerrain;
                tempTerrain.loadFromFaultFormation(luaMap[i].iterations, luaMap[i].width, luaMap[i].length,
                    1, 1, luaMap[i].minHeight, luaMap[i].maxHeight, luaMap[i].filter,
                    luaMap[i].texturePath, GL_TEXTURE_2D);
                tempGuiData.setTerrain(tempTerrain);
                tempGuiData.setObjectType(luaMap[i].objectType);
                tempGuiData.setTexturePath(luaMap[i].texturePath);
                tempGuiData.setNumIterations(luaMap[i].iterations);
                tempGuiData.setWidth(luaMap[i].width);
                tempGuiData.setLength(luaMap[i].length);
                tempGuiData.setMinHeight(luaMap[i].minHeight);
                tempGuiData.setMaxHeight(luaMap[i].maxHeight);
                tempGuiData.setFilter(luaMap[i].filter);
            }
            else if (objectType == "Model")
            {
                tempGuiData.setIsDock(luaMap[i].isDock);
                tempGuiData.setIsPlayer(luaMap[i].isPlayer);
                tempGuiData.setIsHut(luaMap[i].isHut);
                tempGuiData.setIsCollectable(luaMap[i].isCollectable);
                tempGuiData.setModel(luaMap[i].filepath);
                tempGuiData.setObjectType(luaMap[i].objectType);
                tempGuiData.setFilePath(luaMap[i].filepath);
            }
            else if (objectType == "Animation")
            {
                tempGuiData.setObjectType(luaMap[i].objectType);
                tempGuiData.setMd2Model(luaMap[i].filepath , luaMap[i].texturePath);
                if (strlen(luaMap[i].weaponPath) != 0)
                {
                    tempGuiData.setMd2Weapon(luaMap[i].weaponPath, luaMap[i].weaponTexturePath);
                }
                tempGuiData.setFilePath(luaMap[i].filepath);
                tempGuiData.setTexturePath(luaMap[i].texturePath);
                tempGuiData.setWeaponPath(luaMap[i].weaponPath);
                tempGuiData.setWeaponTexturePath(luaMap[i].weaponTexturePath);
            }

            glm::vec3 tempVec;

            tempVec.x = luaMap[i].tx;
            tempVec.y = luaMap[i].ty;
            tempVec.z = luaMap[i].tz;
            tempGuiData.setTranslation(tempVec);

            tempVec.x = luaMap[i].sx;
            tempVec.y = luaMap[i].sy;
            tempVec.z = luaMap[i].sz;
            tempGuiData.setScale(tempVec);

            tempVec.x = luaMap[i].rx;
            tempVec.y = luaMap[i].ry;
            tempVec.z = luaMap[i].rz;
            tempGuiData.setRotation(tempVec);

            convertedData.push_back(tempGuiData);
        }
    }

    /*
     * @brief Sets the ImGuiData objects
     *
     * This functions sets the ImGuiData to store objects
     * that have been loaded from elsewhere but still to be
     * used by ImGui
     *
     * @param dataVec
     * @return void
     */
    void setGuiData(std::vector<ImGuiData> dataVec)
    {
        this->imGuiObjects = dataVec;
    }

    /*
     * @brief Sets the loaded maps
     *
     * This functions sets the currently stored maps
     * as per a string of file paths
     *
     * @param Maps
     * @return void
     */
    void setMaps(std::vector<std::string> Maps)
    {
        this->maps = Maps;
    }

    /*
     * @brief Sets the terrain
     *
     * This functions sets a terrain landscape to 
     * be stored in the ImGuiData
     *
     * @param landscape
     * @return void
     */
    void setTerrain(Landscape landscape)
    {
        this->terrain = landscape;
    }

    /*
     * @brief Sets the water
     *
     * This functions sets a water landscape to 
     * be stored in the ImGuiData
     *
     * @param landscape
     * @return void
     */
    void setWater(Landscape landscape)
    {
        this->water = landscape;
    }

    /*
     * @brief Sets the model
     *
     * This functions sets a model to be stored
     * in the ImGuiData using a given filepath 
     * to a model
     *
     * @param modelPath
     * @return void
     */
    void setModel(const char* modelPath)
    {
        this->model = new Model(modelPath);
    }

    /*
     * @brief Sets the md2 model
     *
     * This functions sets an md2 model to be stored
     * in the ImGuiData using given filepaths
     * to a model and its texture
     *
     * @param md2ModelPath, md2TexturePath
     * @return void
     */
    void setMd2Model(const char* md2ModelPath, const char* md2TexturePath)
    {
        this->md2Model.loadModel(md2ModelPath, md2TexturePath);
    }

    /*
     * @brief Sets the md2 weapon
     *
     * This functions sets a weapon model to be stored
     * in the ImGuiData using given filepaths
     * to a weapon and its texture
     *
     * @param md2WeaponPath, md2WeaponTexturePath
     * @return void
     */
    void setMd2Weapon(const char* md2WeaponPath, const char* md2WeaponTexturePath)
    {
        this->weapon.loadModel(md2WeaponPath, md2WeaponTexturePath);
    }

    /*
     * @brief Sets md2 animation state
     *
     * This functions sets the animation state
     * for the current md2 model as per a given
     * animation type
     *
     * @param type
     * @return void
     */
    void setAnimationState(animationType type)
    {
        this->animState = md2Model.startAnimation(type);
    }

    /*
     * @brief Sets the translation
     *
     * This functions sets the translation
     * of an object stored in ImGuiData
     *
     * @param translate
     * @return void
     */
    void setTranslation(glm::vec3 translate)
    {
        this->translation = translate;
    }

    /*
     * @brief Sets the scale
     *
     * This functions sets the scale
     * of an object stored in ImGuiData
     *
     * @param scale
     * @return void
     */
    void setScale(glm::vec3 scale)
    {
        this->scale = scale;
    }

    /*
     * @brief Sets the rotate
     *
     * This functions sets the rotation
     * of an object stored in ImGuiData
     *
     * @param rotate
     * @return void
     */
    void setRotation(glm::vec3 rotate)
    {
        this->rotation = rotate;
    }

    /*
     * @brief Sets the object type
     *
     * This functions sets the object type
     * of an object stored in ImGuiData
     *
     * @param type
     * @return void
     */
    void setObjectType(std::string type)
    {
        objectType = type;
    }

    /*
     * @brief Sets the file path
     *
     * This functions sets the file path
     * of an object stored in ImGuiData
     *
     * @param filePath
     * @return void
     */
    void setFilePath(const char* filePath)
    {
        filepath = filePath;
    }

    /*
     * @brief Sets the texture path
     *
     * This functions sets the texture path
     * of an object stored in ImGuiData
     *
     * @param texturepath
     * @return void
     */
    void setTexturePath(const char* texturepath)
    {
        texturePath = texturepath;
    }

    /*
     * @brief Sets the weapons file path
     *
     * This functions sets the weapon file path
     * of an animated model stored in ImGuiData
     *
     * @param WeaponPath
     * @return void
     */
    void setWeaponPath(const char* WeaponPath)
    {
        weaponPath = WeaponPath;
    }

    /*
     * @brief Sets the weapons ntexture path
     *
     * This functions sets the weaons texture path
     * of an animated model stored in ImGuiData
     *
     * @param texturepath
     * @return void
     */
    void setWeaponTexturePath(const char* WeaponTexturePath)
    {
        weaponTexturePath = WeaponTexturePath;
    }

    /*
     * @brief Sets the number of iterations
     *
     * This functions sets the number of iterations
     * of a landscape stored in ImGuiData
     *
     * @param numIterations
     * @return void
     */
    void setNumIterations(float numIterations)
    {
        iterations = numIterations;
    }

    /*
     * @brief Sets the terrain width
     *
     * This functions sets the width
     * of a landscape stored in ImGuiData
     *
     * @param Width
     * @return void
     */
    void setWidth(float Width)
    {
        width = Width;
    }

    /*
     * @brief Sets the terrain length
     *
     * This functions sets the length
     * of a landscape stored in ImGuiData
     *
     * @param Length
     * @return void
     */
    void setLength(float Length)
    {
        length = Length;
    }

    /*
     * @brief Sets the terrain minHeight
     *
     * This functions sets the minimum height
     * of a landscape stored in ImGuiData
     *
     * @param MinHeight
     * @return void
     */
    void setMinHeight(float MinHeight)
    {
        minHeight = MinHeight;
    }

    /*
     * @brief Sets the terrain maxHeight
     *
     * This functions sets the maximum height
     * of a landscape stored in ImGuiData
     *
     * @param MaxHeight
     * @return void
     */
    void setMaxHeight(float MaxHeight)
    {
        maxHeight = MaxHeight;
    }

    /*
     * @brief Sets the terrain filter
     *
     * This functions sets the filter
     * of a landscape stored in ImGuiData
     *
     * @param Filter
     * @return void
     */
    void setFilter(float Filter)
    {
        filter = Filter;
    }

    /*
     * @brief Sets the player status
     *
     * This functions sets the player status of the
     * current object
     *
     * @param IsPlayer
     * @return void
     */
    void setIsPlayer(bool IsPlayer)
    {
        isPlayer = IsPlayer;
    }

    /*
     * @brief Sets the dock status
     *
     * This functions sets the dock status of the
     * current object
     *
     * @param IsDock
     * @return void
     */
    void setIsDock(bool IsDock)
    {
        isDock = IsDock;
    }

    /*
     * @brief Sets the hut status
     *
     * This functions sets the hut status of the
     * current object
     *
     * @param IsHut
     * @return void
     */
    void setIsHut(bool IsHut)
    {
        isHut = IsHut;
    }

    /*
     * @brief Sets the collectable status
     *
     * This functions sets the collectable status of the
     * current object
     *
     * @param IsCollectable
     * @return void
     */
    void setIsCollectable(bool IsCollectable)
    {
        isCollectable = IsCollectable;
    }

    /*
     * @brief Sets the player
     *
     * This functions sets the current object
     * to be a player
     *
     * @param player
     * @return void
     */
    void setPlayer(ImGuiData player)
    {
        for (int i = 0; i < imGuiObjects.size(); i++)
        {
            if (imGuiObjects[i].isPlayer)
                imGuiObjects[i] = player;
        }
    }

    /*
     * @brief Sets the NPCs
     *
     * This functions sets the values of the NPCs
     * as per given NPC data
     *
     * @param NPCs
     * @return void
     */
    void setNPCs(std::vector<ImGuiData> NPCs)
    {
        int latestNPC = 0;
        for (int i = 0; i < NPCs.size(); i++)
        {
            for (int j = latestNPC; j < imGuiObjects.size(); j++)
            {
                if (imGuiObjects[j].objectType == "Animation")
                {
                    imGuiObjects[j] = NPCs[i];
                    latestNPC = j + 1;
                    j = imGuiObjects.size();
                }
            }
        }
    }

    /*
     * @brief Sets the docks
     *
     * This functions sets the values of the docks
     * as per given dock data
     *
     * @param Docks
     * @return void
     */
    void setDocks(std::vector<ImGuiData> Docks)
    {
        int latestDock = 0;
        for (int i = 0; i < Docks.size(); i++)
        {
            for (int j = latestDock; j < imGuiObjects.size(); j++)
            {
                if (imGuiObjects[j].isDock)
                {
                    imGuiObjects[j] = Docks[i];
                    latestDock = j + 1;
                    j = imGuiObjects.size();
                }
            }
        }
    }

    /*
     * @brief Sets the collectables
     *
     * This functions sets the values of the 
     * collectables as per given collectable data
     *
     * @param Collectables
     * @return void
     */
    void setCollectables(std::vector<ImGuiData> Collectables)
    {
        int latestCollectable = 0;
        for (int i = 0; i < Collectables.size(); i++)
        {
            for (int j = latestCollectable; j < imGuiObjects.size(); j++)
            {
                if (imGuiObjects[j].isCollectable)
                {
                    imGuiObjects[j] = Collectables[i];
                    latestCollectable = j + 1;
                    j = imGuiObjects.size();
                }
            }
        }
    }

    /*
     * @brief Gets the heightScale
     *
     * This function returns the height scale of an
     * object stored in ImGuiData
     *
     * @return heightScale
     */
    int getHeightScale()
    {
        return heightScale;
    }

    /*
     * @brief Gets the player
     *
     * If a player is stored within the object
     * data then the players data is returned
     *
     * @return ImGuiObject[i]
     */
    ImGuiData getPlayer()
    {
        for (int i = 0; i < imGuiObjects.size(); i++)
        {
            if (imGuiObjects[i].isPlayer)
                return imGuiObjects[i];
        }

        ImGuiData none;

        return (none);
    }

    /*
     * @brief Gets the NPCs
     *
     * This function returns the data for
     * every NPC object currently stored
     *
     * @return NPCs
     */
    std::vector<ImGuiData> getNPCs()
    {
        std::vector<ImGuiData> NPCs;

        for (int i = 0; i < imGuiObjects.size(); i++)
        {
            if (imGuiObjects[i].objectType == "Animation")
                NPCs.push_back(imGuiObjects[i]);
        }

        return (NPCs);
    }

    /*
     * @brief Gets the Docks
     *
     * This function returns the data for
     * every dock object currently stored
     *
     * @return Docks
     */
    std::vector<ImGuiData> getDocks()
    {
        std::vector<ImGuiData> Docks;

        for (int i = 0; i < imGuiObjects.size(); i++)
        {
            if (imGuiObjects[i].isDock)
                Docks.push_back(imGuiObjects[i]);
        }

        return (Docks);
    }

    /*
     * @brief Gets the hut
     *
     * If a hut is stored within the object
     * data then the huts data is returned
     *
     * @return ImGuiObject[i]
     */
    ImGuiData getHut()
    {
        for (int i = 0; i < imGuiObjects.size(); i++)
        {
            if (imGuiObjects[i].isHut)
                return imGuiObjects[i];
        }

        ImGuiData none;

        return (none);
    }

    /*
     * @brief Gets the Collectables
     *
     * This function returns the data for
     * every collectable object currently stored
     *
     * @return Collectables
     */
    std::vector<ImGuiData> getCollectables()
    {
        std::vector<ImGuiData> Collectables;

        for (int i = 0; i < imGuiObjects.size(); i++)
        {
            if (imGuiObjects[i].isCollectable)
                Collectables.push_back(imGuiObjects[i]);
        }

        return (Collectables);
    }

    /*
     * @brief Gets the translation
     *
     * This function returns the translation
     * of the current object
     *
     * @return translation
     */
    glm::vec3 getTranslation()
    {
        return translation;
    }

    /*
     * @brief Gets the rotation
     *
     * This function returns the rotation
     * of the current object
     *
     * @return rotation
     */
    glm::vec3 getRotation()
    {
        return rotation;
    }

    /*
     * @brief Gets the delta time
     *
     * This function returns the delta time
     * of the current object
     *
     * @return deltaTime
     */
    float getDeltaTime()
    {
        return this->deltaTime;
    }

    /*
     * @brief Gets the animation status
     *
     * This function returns the animation status
     * of the current object
     *
     * @return animStatus
     */
    bool getAnimStatus()
    {
        return this->md2Model.getAnimationStatus();
    }

    /*
     * @brief Gets the terrains
     *
     * This function returns the data for
     * every terrain object currently stored
     *
     * @return terrains
     */
    std::vector<Terrain> getTerrains()
    {
        std::vector<Terrain> terrains;

        for (int i = 0; i < imGuiObjects.size(); i++)
        {
            if (imGuiObjects[i].objectType == "Terrain")
            {
                terrains.push_back(imGuiObjects[i].terrain.getTerrain());
            }
        }

        return terrains;
    }
};